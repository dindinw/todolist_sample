package test.io.dindinw.lang;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Objects;
import java.util.function.Function;
import java.util.function.IntFunction;

import io.dindinw.lang.Convert;
import org.junit.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

/**
 * The initial purpose of Test is to answer the question that why two object are not equals
 * BUT with the SAME hashcode.
 * <p/>
 * REFS:
 * http://eclipsesource.com/blogs/2012/09/04/the-3-things-you-should-know-about-hashcode/
 * http://www.ibm.com/developerworks/library/j-jtp05273/
 * http://www.javaworld.com/article/2077346/core-java/hashtables.html
 */
public class HashCodeTest {
    private static final Logger LOG = LoggerFactory.getLogger(HashCodeTest.class);
    @Test
    public void testObjectsEquals() {
        Object a = new Object();
        Object b = new Object();

        //In Java
        // return (a == b) || (a != null && a.equals(b))
        // 1. == make sure if two reference are same
        // 2. equals means:
        //    in Object the implementation is still (this == obj), if there is no overridden method.
        assertFalse(Objects.equals(a, b)); //JDK 7 Unity for Object with null-safe/tolerant

        // Object's hashCode() and System.identityHashCode(a);
        // Both of them are native method in Java (JVM)

        // According to JLS :
        // here only Two Implies :
        // 1.) A.equals(B) implies B.hashcode() == A.hashcode()
        if (a.equals(b)) {
            assertTrue(a.hashCode() == b.hashCode()); //always true by JLS
        }
        // 2.) B.hashcode() != A.hashcode() implies !A.equals(B)
        if (a.hashCode() != b.hashCode()) {
            assertTrue(!a.equals(b));
        }

        // We can't make any assumption that hashcode are same so that the objects are equals
        //  a.hashcode() == b.hashCode() =X=>  a.equals(b)

        // From Java Doc
        // http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html#hashCode()
        // http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#hashCode()
        // http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#hashCode--
        /*
         * <p>
         * The general contract of {@code hashCode} is:
         * <ul>
         * <li>Whenever it is invoked on the same object more than once during
         *     an execution of a Java application, the {@code hashCode} method
         *     must consistently return the same integer, provided no information
         *     used in {@code equals} comparisons on the object is modified.
         *     This integer need not remain consistent from one execution of an
         *     application to another execution of the same application.
         * <li>If two objects are equal according to the {@code equals(Object)}
         *     method, then calling the {@code hashCode} method on each of
         *     the two objects must produce the same integer result.
         * <li>It is <em>not</em> required that if two objects are unequal
         *     according to the {@link java.lang.Object#equals(java.lang.Object)}
         *     method, then calling the {@code hashCode} method on each of the
         *     two objects must produce distinct integer results.  However, the
         *     programmer should be aware that producing distinct integer results
         *     for unequal objects may improve the performance of hash tables.
         * </ul>
         */
        // r1 : o1.hashcode() == o1.hashcode()
        // r2 : if (o1.equals(o2)) then o1.hashcode == o2.hashcode()
        // r3 : if (!o1.equals(o2)), CANNOT deduce that o1.hashcode() != o2.hashcode()

        // See Also
        // Josh Bloch's "Effective Java 2nd Edition"
        // Item 9: Always override hashCode() when you override equals()
        //

        Person p1 = new Person("Alex",35);
        Person p2 = new Person("Alex",35);

        //hashcode p1@3c699a5 p2@3c699a5
        printHash("hashcode p1@{} p2@{} ", p1.hashCode(), p2.hashCode());
        assertTrue(p1.hashCode() == p2.hashCode());
        assertTrue(p1.equals(p2));
        Man m1 = new Man("Alex",35);
        assertTrue(m1.hashCode() == p1.hashCode());

        //hashcode m1@3c699a5 p1@3c699a5 p2@3c699a5
        printHash("hashcode m1@{} p1@{} p2@{} ", m1.hashCode(), p1.hashCode(), p2.hashCode());
        printHash("           @{}  @{}   @{} ", System.identityHashCode(m1), System.identityHashCode(p1), System.identityHashCode(p2));

        // always fixed
        assertEquals("3c699a5", Integer.toHexString(m1.hashCode()));

        Life l1 = new Life("Alex",35);
        Life l2 = new Life("Alex",35);

        // here hashcode is generated by JVM native
        printHash("hashcode l1@{} l2@{} ", l1.hashCode(), l2.hashCode());

        assertEquals(System.identityHashCode(l1),l1.hashCode());
        assertFalse(l1.equals(l2));

        // but in the case !o1.equals(o2) && o1.hashcode() == o2.hashcode(),  the performance of hash container is bad
        final Object setHolder = new Object();
        HashMap<Person,Object> set = new HashMap<>(); //here is a HashSet (a HashSet just a HashMap with a unique value)
        set.put(p1,setHolder);

        // when a key push into HashMap, it calculate it's hashcode by it's hashcode() method
        //    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
        // then try to put it into bucket
        //            if ((p = tab[i = (n - 1) & hash]) == null)
        //                 tab[i] = newNode(hash, key, value, null);
        // the tab is the bucket array. if every key has different hashcode, so that the tab[i] the one and single one,
        // in this saturation, the HashMap performance best.
        assertNotNull(set.get(p1));

        // when try to get value by key, it always check the first one in the bucket
        //      (first = tab[(n - 1) & hash]) != null) {
        //             if (first.hash == hash && // always check first node
        // So that if the first one is the one looking for, the HashMap will performance best.

        // so if two objects has same hashCode. hashMap will placing the two into the same bucket
        // when we get some from HashMap, we will get multiple values from the hash bucket. so HashMap need to do
        // a sequential search for the value in the bucket.
        // In impl, it will try to look up a tree

        assertNotNull(set.get(p2)); //wired one :-), why we can do this!

        // Back to our case.
        // because, in a HashMap, only two thing is important to get a value. the k.hashcode() and k.equals()
        // In another word. if we can make sure that
        //  1.) k1.hashCode() == k2.hashCode()
        //  2.) k1.equals(k2)
        // So that k2 can fool HashMap

        Object evilOne = new Person("Alex",35){
            @Override
            public boolean equals(Object o) {
                return true; //how evil I am !
            }
        };
        assertTrue(evilOne.hashCode()==p2.hashCode());
        assertTrue(evilOne.equals(p2));

        assertEquals(evilOne, p2);
        assertFalse(evilOne == p2); //evilOne is not same with p2

        assertNotNull(set.get(evilOne));
        assertTrue(setHolder == set.get(evilOne));

        //So that I can build a evil Object like above to fool the HashMap
        LOG.info("evil one");
    }

    static void printHash(String msgTemp,Integer... hashCode){
        LOG.info(msgTemp, Convert.convertArray(hashCode, Integer::toHexString, String[]::new));
    }


    class Life{
        private String name;
        private Integer age;
        Life(String name, Integer age){
            this.name = name;
            this.age = age;
        }
    }
    class Man extends Person {
       Man(String name,Integer age){
           super(name,age);
       }
    }
    class Person {
        private String name;
        private Integer age;

        Person(String name, Integer age) {
            this.name = name;
            this.age = age;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;

            Person person = (Person) o;

            if (!name.equals(person.name)) return false;
            return age.equals(person.age);

        }

        @Override
        public int hashCode() {
            int result = name.hashCode();
            result = 31 * result + age.hashCode();
            return result;
        }
    }
}
